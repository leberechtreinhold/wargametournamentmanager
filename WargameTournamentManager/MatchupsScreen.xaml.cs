using MahApps.Metro.Controls.Dialogs;
using System;
using System.Collections.Generic;
using System.Data;
using System.Globalization;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Windows;
using System.Windows.Controls;
using System.Windows.Data;
using System.Windows.Documents;
using System.Windows.Input;
using System.Windows.Media;
using System.Windows.Media.Imaging;
using System.Windows.Navigation;
using System.Windows.Shapes;

namespace WargameTournamentManager
{
    /// <summary>
    /// Interaction logic for MatchupsScreen.xaml
    /// </summary>
    public partial class MatchupsScreen : UserControl
    {
        public ViewMatchup EditingMatchup { get; set; }

        public MatchupsScreen()
        {
            InitializeComponent();
        }

        private void EditMatchup_Click(object sender, RoutedEventArgs e)
        {
            var matchup = ((Button)e.Source).DataContext as Matchup;
            if (matchup == null) return;

            EditingMatchup = new ViewMatchup(matchup, MainWindow.gMainWindow.currentTournament);
            editMatchupWindow.DataContext = EditingMatchup;
            editMatchupWindow.IsOpen = true;
        }

        private void SaveMatchup_Click(object sender, RoutedEventArgs e)
        {
            EditingMatchup.UpdateMatchupWithView();
            editMatchupWindow.IsOpen = false;
        }

        private void GeneratePairings_Click(object sender, RoutedEventArgs e)
        {
            if (!MainWindow.gMainWindow.currentTournament.PlayerListLocked)
            {
                MainWindow.gMainWindow.ShowMessageAsync("Error", "No se pueden generar enfrentamientos para una ronda sin que la lista de jugadores esté cerrada.");
                return;
            }
            var selectedRound = ((Button)sender).DataContext as Round;
            if (!selectedRound.Active)
            {
                MainWindow.gMainWindow.ShowMessageAsync("Error", "No se pueden generar enfrentamientos para una ronda que no está activa.");
                return;
            }
            MainWindow.gMainWindow.currentTournament.GenerateMatchupById();
        }

        private async void CloseRound_Click(object sender, RoutedEventArgs e)
        {
            var selectedRound = ((Button)sender).DataContext as Round;
            var oldIndex = MainWindow.gMainWindow.currentTournament.CurrentRound;
            try
            {
                MainWindow.gMainWindow.currentTournament.FinishRound(selectedRound);
            }
            catch (InvalidOperationException ex)
            {
                await MainWindow.gMainWindow.ShowMessageAsync("Error", ex.Message);
            }

            var newIndex = MainWindow.gMainWindow.currentTournament.CurrentRound;
            if (oldIndex != newIndex)
            {
                TabRounds.SelectedIndex += newIndex;
                
            }
        }
    }

    // The matchup is very different from view from the model, because the model is
    // a strict hierarchy with no links up, and the view is something with many options
    // context dependant with translated, autogenerated strings. Also WPF conversion
    // from WPF is not direct
    public class ViewMatchup
    {
        public Matchup SourceMatchup { get; set; }
        public Tournament SourceTournament { get; set; }
        public DataTable Tags { get; set; }
        public int IndexCurrentResult { get; set; }

        public List<string> Results
        {
            get
            {
                return new List<string>
                {
                    "Jugándose",
                    string.Format("Victoria de {0}", Player1Name),
                    string.Format("Victoria de {0}", Player2Name),
                    "Empate"
                };
            }
        }
        public string MatchupName
        {
            get
            {
                return string.Format("{0} vs {1}", Player1Name, Player2Name);
            }
        }

        public string Player1Name
        {
            get
            {
                return SourceTournament.Players[SourceMatchup.Player1Id].Name;
            }
        }

        public string Player2Name
        {
            get
            {
                return SourceTournament.Players[SourceMatchup.Player2Id].Name;
            }
        }

        public ViewMatchup(Matchup _sourceMatchup, Tournament _sourceTournament)
        {
            SourceMatchup = _sourceMatchup;
            SourceTournament = _sourceTournament;

            IndexCurrentResult = (int)SourceMatchup.CurrentResult;
            Tags = new DataTable();
            Tags.Columns.Add("Tag");
            Tags.Columns.Add(Player1Name);
            Tags.Columns.Add(Player2Name);
            foreach(var tagPair in SourceMatchup.Player1Tags)
            {
                Tags.Rows.Add(tagPair.Key, tagPair.Value, SourceMatchup.Player2Tags[tagPair.Key]);
            }
        }

        public void UpdateMatchupWithView()
        {
            SourceMatchup.CurrentResult = (Result)IndexCurrentResult;
            SourceTournament.UpdateRanking();
            // TODO Update tags
            SourceTournament.Save();

            // Band aid because there should be no need to execute this 
            // to make the datagrid refresh
            var round = SourceTournament.Rounds[SourceMatchup.Round - 1];
            var updated_matchups = new List<Matchup>();
            foreach (var matchup in round.Matchups)
            {
                updated_matchups.Add(matchup);
            }
            round.Matchups = updated_matchups;
            round.OnPropertyChanged("Matchups");
        }
    }

    public sealed class GetMatchupResultConverter : IMultiValueConverter
    {
        public object Convert(object[] values, Type targetType, object parameter, CultureInfo culture)
        {
            if (values.Length != 2) return null;

            Matchup matchup = values[0] as Matchup;
            Tournament tournament = values[1] as Tournament;
            if (matchup == null || tournament == null)
                return null;

            if (matchup.CurrentResult == Result.STILL_PLAYING)
            {
                return "Jugando";
            }
            else if (matchup.CurrentResult == Result.DRAW)
            {
                return "Empate";
            }
            else
            {
                int winner = matchup.CurrentResult == Result.PLAYER1_WIN ? matchup.Player1Id : matchup.Player2Id;
                return string.Format("Victoria para {0}", tournament.Players[winner].Name);
            }
        }

        public object[] ConvertBack(object value, Type[] targetTypes, object parameter, CultureInfo culture)
        {
            throw new NotImplementedException();
        }
    }

    public sealed class GetRoundActiveOrNotConverter : IValueConverter
    {
        public object Convert(object value, Type targetType, object parameter, CultureInfo culture)
        {
            if ((bool)value) return "Ronda en curso";
            else return "NOTA: Ronda no activa, no se pueden editar los resultados de los enfrentamientos ni generar enfrentamientos.";
        }

        public object ConvertBack(object value, Type targetType, object parameter, CultureInfo culture)
        {
            throw new NotImplementedException();
        }
    }

    public sealed class GetMatchupNameConverter : IMultiValueConverter
    {
        public object Convert(object[] values, Type targetType, object parameter, CultureInfo culture)
        {
            if (values.Length != 3) return null;

            var player1Id = values[0] as int?;
            var player2Id = values[1] as int?;
            Tournament tournament = values[2] as Tournament;
            if (player1Id == null || player2Id == null || tournament == null)
                return null;

            var player1 = tournament.Players[(int)player1Id];
            var player2 = tournament.Players[(int)player2Id];
            return string.Format("{0} vs {1}", player1.Name, player2.Name);
        }

        public object[] ConvertBack(object value, Type[] targetTypes, object parameter, CultureInfo culture)
        {
            throw new NotImplementedException();
        }
    }

}
